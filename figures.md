# FIGURES.C - Система работы с фигурами Тетрис

## Обзор модуля

`brick_game/tetris/figures.c` реализует полную систему работы с 7 стандартными тетромино:
- **Точные шаблоны всех фигур** в 4 поворотах
- **Система поворотов** с валидацией
- **Проверка коллизий** с полем и границами
- **Размещение фигур** на игровом поле
- **Генерация случайных фигур**

## Система фигур

### 7 типов тетромино (стандарт)
```c
typedef enum {
    FIGURE_I = 0,  // Палка (I-piece)
    FIGURE_O = 1,  // Квадрат (O-piece)
    FIGURE_T = 2,  // Т-образная (T-piece)
    FIGURE_S = 3,  // S-образная (S-piece)
    FIGURE_Z = 4,  // Z-образная (Z-piece)
    FIGURE_J = 5,  // J-образная (J-piece)
    FIGURE_L = 6   // L-образная (L-piece)
} FigureType_t;
```

### Структура фигуры
```c
typedef struct {
    FigureType_t type;     // Тип фигуры (0-6)
    int blocks[4][4];      // Матрица блоков 4x4
    Point_t position;      // Позиция на поле (x, y)
    int rotation;          // Поворот (0-3)
} Figure_t;
```

## Шаблоны фигур

### Система хранения шаблонов
**Файл:** `figures.c:13-63`

```c
static const int FIGURE_TEMPLATES[FIGURE_TYPES_COUNT][4][4][4] = {
    // [тип_фигуры][поворот][y][x]
};
```

**Структура массива:**
- **7 типов фигур** × **4 поворота** × **4×4 матрица**
- Каждый элемент: `0` (пусто) или `1` (блок фигуры)
- Поворот 0° = базовое положение

### Детальные шаблоны фигур

#### I-piece (Палка) - FIGURE_I
```c
// Базово ВЕРТИКАЛЬНАЯ, сверху
{
    {{0,1,0,0}, {0,1,0,0}, {0,1,0,0}, {0,1,0,0}}, // 0° - вертикально
    {{0,0,0,0}, {1,1,1,1}, {0,0,0,0}, {0,0,0,0}}, // 90° - горизонтально
    {{0,1,0,0}, {0,1,0,0}, {0,1,0,0}, {0,1,0,0}}, // 180° - вертикально
    {{0,0,0,0}, {1,1,1,1}, {0,0,0,0}, {0,0,0,0}}  // 270° - горизонтально
}
```

**Особенности:**
- Единственная фигура размером 4 блока
- Чередует вертикальное/горизонтальное положение
- Центрирована в колонке 1 (индекс x=1) при вертикальном положении

#### O-piece (Квадрат) - FIGURE_O
```c
// ЦЕНТРИРОВАННЫЙ квадрат
{
    {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}}, // Все повороты одинаковы
    {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
    {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}},
    {{0,1,1,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}}
}
```

**Особенности:**
- Не изменяется при поворотах
- Занимает 2×2 в центре матрицы 4×4
- Самая стабильная фигура

#### T-piece (Т-образная) - FIGURE_T
```c
// Базово вертикально с выступом ВПРАВО
{
    {{0,1,0,0}, {0,1,1,0}, {0,1,0,0}, {0,0,0,0}}, // 0° - выступ вправо
    {{0,0,0,0}, {1,1,1,0}, {0,1,0,0}, {0,0,0,0}}, // 90° - выступ вниз
    {{0,1,0,0}, {1,1,0,0}, {0,1,0,0}, {0,0,0,0}}, // 180° - выступ влево
    {{0,1,0,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}}  // 270° - выступ вверх
}
```

**Особенности:**
- Наиболее универсальная для заполнения пробелов
- Четко выраженная ось поворота
- Используется в "T-spin" маневрах

#### S-piece (S-образная) - FIGURE_S
```c
// Горизонтальная S, сверху
{
    {{0,1,1,0}, {1,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // 0° - горизонтальная S
    {{0,1,0,0}, {0,1,1,0}, {0,0,1,0}, {0,0,0,0}}, // 90° - вертикальная S
    {{0,1,1,0}, {1,1,0,0}, {0,0,0,0}, {0,0,0,0}}, // 180° - горизонтальная S
    {{0,1,0,0}, {0,1,1,0}, {0,0,1,0}, {0,0,0,0}}  // 270° - вертикальная S
}
```

#### Z-piece (Z-образная) - FIGURE_Z
```c
// Горизонтальная Z, сверху (зеркальная к S)
{
    {{1,1,0,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}}, // 0° - горизонтальная Z
    {{0,1,0,0}, {1,1,0,0}, {1,0,0,0}, {0,0,0,0}}, // 90° - вертикальная Z
    {{1,1,0,0}, {0,1,1,0}, {0,0,0,0}, {0,0,0,0}}, // 180° - горизонтальная Z
    {{0,1,0,0}, {1,1,0,0}, {1,0,0,0}, {0,0,0,0}}  // 270° - вертикальная Z
}
```

#### J-piece (J-образная) - FIGURE_J
```c
// Вертикально с выступом внизу ВЛЕВО
{
    {{0,1,0,0}, {0,1,0,0}, {1,1,0,0}, {0,0,0,0}}, // 0° - выступ внизу влево
    {{1,0,0,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}}, // 90° - выступ влево вверх
    {{0,1,1,0}, {0,1,0,0}, {0,1,0,0}, {0,0,0,0}}, // 180° - выступ вверху вправо
    {{0,0,0,0}, {1,1,1,0}, {0,0,1,0}, {0,0,0,0}}  // 270° - выступ вправо вниз
}
```

#### L-piece (L-образная) - FIGURE_L
```c
// Вертикально с выступом внизу ВПРАВО (зеркальная к J)
{
    {{0,1,0,0}, {0,1,0,0}, {0,1,1,0}, {0,0,0,0}}, // 0° - выступ внизу вправо
    {{0,0,0,0}, {1,1,1,0}, {1,0,0,0}, {0,0,0,0}}, // 90° - выступ влево вниз
    {{1,1,0,0}, {0,1,0,0}, {0,1,0,0}, {0,0,0,0}}, // 180° - выступ вверху влево
    {{0,0,1,0}, {1,1,1,0}, {0,0,0,0}, {0,0,0,0}}  // 270° - выступ вправо вверх
}
```

## Создание и управление фигурами

### tetris_create_figure() - Создание новой фигуры
**Файл:** `figures.c:74-95`

```c
Figure_t tetris_create_figure(FigureType_t type) {
    Figure_t figure;

    // Проверяем валидность типа
    if (type < 0 || type >= FIGURE_TYPES_COUNT) {
        type = FIGURE_I;  // Fallback к палке
    }

    figure.type = type;
    figure.position.x = FIELD_WIDTH / 2 - 2;  // Центр поля (10/2-2 = 3)
    figure.position.y = 0;                    // Верх поля
    figure.rotation = 0;                      // Базовое положение

    // Копируем шаблон базового положения
    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            figure.blocks[y][x] = FIGURE_TEMPLATES[type][0][y][x];
        }
    }

    return figure;
}
```

**Алгоритм позиционирования:**
- **X-позиция:** `FIELD_WIDTH / 2 - 2` = 3 (для поля шириной 10)
- **Y-позиция:** 0 (верх поля)
- **Обоснование:** Матрица 4×4 с позицией (3,0) центрирует фигуру

**Fallback система:**
- При недопустимом типе → автоматически `FIGURE_I`
- Гарантирует создание валидной фигуры

### tetris_get_random_figure_type() - Случайная фигура
**Файл:** `figures.c:135-137`

```c
FigureType_t tetris_get_random_figure_type(void) {
    return (FigureType_t)(rand() % FIGURE_TYPES_COUNT);
}
```

**Использование:**
- Равномерное распределение всех 7 типов
- Зависит от `srand()` инициализации в `tetris_init()`

## Система поворотов

### tetris_rotate_figure() - Поворот фигуры
**Файл:** `figures.c:103-129`

```c
bool tetris_rotate_figure(Figure_t *figure, bool clockwise) {
    if (!figure) return false;

    // Проверяем валидность типа
    FigureType_t type = figure->type;
    if (type < 0 || type >= FIGURE_TYPES_COUNT) {
        return false;
    }

    // Вычисляем новый поворот
    int new_rotation;
    if (clockwise) {
        new_rotation = (figure->rotation + 1) % 4;    // 0→1→2→3→0
    } else {
        new_rotation = (figure->rotation + 3) % 4;    // 0→3→2→1→0 (это -1 mod 4)
    }

    // Применяем новый поворот
    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            figure->blocks[y][x] = FIGURE_TEMPLATES[type][new_rotation][y][x];
        }
    }

    figure->rotation = new_rotation;
    return true;
}
```

**Математика поворотов:**
- **По часовой:** `(rotation + 1) % 4`
- **Против часовой:** `(rotation + 3) % 4` (эквивалент `rotation - 1`)
- Циклический переход: 0 ↔ 1 ↔ 2 ↔ 3 ↔ 0

**Важные особенности:**
- Функция НЕ проверяет коллизии
- Возвращает `true` при успешном повороте
- Проверку коллизий делает FSM отдельно

## Система коллизий

### tetris_check_collision() - Проверка коллизий
**Файл:** `figures.c:151-177`

```c
bool tetris_check_collision(const Figure_t *figure, int **field, int offset_x, int offset_y) {
    if (!figure || !field) return true;  // Безопасность: считаем коллизией

    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            if (figure->blocks[y][x] != 0) {  // Только заполненные блоки
                int field_x = figure->position.x + x + offset_x;
                int field_y = figure->position.y + y + offset_y;

                // Проверка границ поля
                if (field_x < 0 || field_x >= FIELD_WIDTH ||
                    field_y < 0 || field_y >= FIELD_HEIGHT) {
                    return true;  // Коллизия с границей
                }

                // Проверка занятых клеток (игнорируем мигающие блоки)
                int cell_value = field[field_y][field_x];
                if (cell_value >= 100) cell_value -= 100;  // Убираем флаг мигания
                if (cell_value != 0) {
                    return true;  // Коллизия с существующими блоками
                }
            }
        }
    }

    return false;  // Коллизий нет
}
```

**Типы коллизий:**

#### 1. Границы поля
```c
if (field_x < 0 || field_x >= FIELD_WIDTH ||   // Лево/право (0-9)
    field_y < 0 || field_y >= FIELD_HEIGHT) {  // Верх/низ (0-19)
    return true;
}
```

#### 2. Существующие блоки
```c
int cell_value = field[field_y][field_x];
if (cell_value >= 100) cell_value -= 100;  // Убираем флаг мигания
if (cell_value != 0) {
    return true;  // Коллизия
}
```

**Обработка мигающих блоков:**
- При анимации очистки линий блоки получают +100
- Коллизия игнорирует мигание: `value >= 100 ? value - 100 : value`
- Позволяет корректно работать во время анимации

**Система offset'ов:**
- `offset_x`, `offset_y` - виртуальное смещение для проверки
- Используется для проверки движения БЕЗ изменения позиции
- Примеры: движение влево (-1,0), падение (0,1), поворот (0,0)

## Размещение фигур на поле

### tetris_place_figure_on_field() - Размещение фигуры
**Файл:** `figures.c:184-201`

```c
void tetris_place_figure_on_field(const Figure_t *figure, int **field) {
    if (!figure || !field) return;

    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            if (figure->blocks[y][x] != 0) {  // Только заполненные блоки
                int field_x = figure->position.x + x;
                int field_y = figure->position.y + y;

                // Проверяем границы (безопасность)
                if (field_x >= 0 && field_x < FIELD_WIDTH &&
                    field_y >= 0 && field_y < FIELD_HEIGHT) {
                    field[field_y][field_x] = figure->type + 1;  // +1 чтобы избежать 0
                }
            }
        }
    }
}
```

**Кодирование типов в поле:**
```c
field[y][x] = figure->type + 1;
```

**Схема кодирования:**
- `FIGURE_I` (0) → поле содержит `1`
- `FIGURE_O` (1) → поле содержит `2`
- `FIGURE_T` (2) → поле содержит `3`
- `FIGURE_S` (3) → поле содержит `4`
- `FIGURE_Z` (4) → поле содержит `5`
- `FIGURE_J` (5) → поле содержит `6`
- `FIGURE_L` (6) → поле содержит `7`

**Обоснование +1:**
- Поле использует `0` для пустых клеток
- Значения 1-7 обозначают разные типы блоков
- Позволяет различать блоки разных фигур (полезно для GUI)

## Интеграция с другими модулями

### Взаимодействие с FSM
**Основные точки интеграции:**

#### 1. Создание фигур (STATE_SPAWN)
```c
state->next_figure = tetris_create_figure(tetris_get_random_figure_type());
```

#### 2. Проверка движения (STATE_MOVING)
```c
if (!tetris_check_collision(&state->current_figure, field, -1, 0)) {
    state->current_figure.position.x--;  // Движение влево
}
```

#### 3. Проверка поворота (пользовательский ввод)
```c
Figure_t temp = state->current_figure;
if (tetris_rotate_figure(&temp, true)) {
    if (!tetris_check_collision(&temp, field, 0, 0)) {
        state->current_figure = temp;  // Применяем поворот
    }
}
```

#### 4. Автопадение (STATE_MOVING)
```c
if (!tetris_check_collision(&figure, field, 0, 1)) {
    figure.position.y++;  // Падение
} else {
    // Переход к STATE_ATTACHING
}
```

#### 5. Размещение (STATE_ATTACHING)
```c
tetris_place_figure_on_field(&state->current_figure, field);
```

### Взаимодействие с game_field.c
- **Клонирование поля:** `tetris_clone_field_and_add_current_figure()` принимает буфер для вывода
- **Обновление next матрицы:** `tetris_update_next_matrix()`
- **Очистка линий:** после размещения фигуры

## Математические аспекты

### Координатная система
```
Поле 10×20:
  0 1 2 3 4 5 6 7 8 9  ← X (ширина)
0 . . . . . . . . . .
1 . . . . . . . . . .
2 . . . . . . . . . .
...
19. . . . . . . . . .
↑
Y (высота)
```

### Матрица фигуры 4×4
```
Фигура с позицией (3, 1):
  0 1 2 3  ← локальные координаты
0 . . . .
1 . X . .  ← блок в (1,1) → поле (4,2)
2 . . . .
3 . . . .
↑
локальные координаты

Преобразование: field_x = figure.position.x + local_x
                field_y = figure.position.y + local_y
```

### Алгоритм поворота
Не используется математический поворот матрицы, а предзаписанные шаблоны:

**Математический поворот (НЕ используется):**
```c
// 90° по часовой стрелке: new[x][y] = old[3-y][x]
// 90° против часовой: new[x][y] = old[y][3-x]
```

**Используемый подход (шаблоны):**
```c
figure->blocks[y][x] = FIGURE_TEMPLATES[type][rotation][y][x];
```

**Преимущества шаблонного подхода:**
- Точность форм (каждая фигура настроена вручную)
- Нет ошибок округления
- Простота реализации и отладки
- Возможность нестандартных форм

## Производительность и оптимизация

### Критические функции
1. **`tetris_check_collision()`** - вызывается очень часто
2. **`tetris_place_figure_on_field()`** - вызывается при каждом прикреплении
3. **`tetris_rotate_figure()`** - при каждом повороте

### Оптимизации
1. **Ранний выход в коллизиях** - проверка границ перед проверкой поля
2. **Константные шаблоны** - никаких вычислений во время игры
3. **Минимальные аллокации** - работа с существующими структурами
4. **Эффективные циклы** - фиксированные размеры 4×4

### Потенциальные улучшения
1. **Кэширование проверок коллизий** для повторных запросов
2. **Битовые маски** вместо матриц 4×4 (экономия памяти)
3. **Предвычисление позиций блоков** для каждого поворота
4. **SIMD инструкции** для массовых проверок коллизий