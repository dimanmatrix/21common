1) Что концептуально представляет собой атрибут сущностей er?

В модели "сущность-связь" (ER-модели) атрибут сущности представляет собой характеристику или свойство, которое описывает сущность. Сущности — это объекты или концепции, которые имеют независимое существование и могут быть идентифицированы в контексте базы данных. Атрибуты, в свою очередь, предоставляют дополнительную информацию о сущностях.
Основные характеристики атрибутов:
	1	Тип данных: Каждый атрибут имеет определенный тип данных, который определяет, какие значения он может принимать (например, строка, целое число, дата и т.д.).
	2	Имя: Атрибут имеет уникальное имя в контексте сущности, которое используется для его идентификации.
	3	Значения: Атрибуты могут принимать различные значения для разных экземпляров сущности. Например, для сущности "Студент" атрибут "Имя" может иметь значения "Алиса", "Боб" и т.д.
	4	Обязательность: Атрибуты могут быть обязательными (т.е. должны иметь значение для каждого экземпляра сущности) или необязательными (т.е. могут оставаться пустыми).
	5	Типы атрибутов:
	•	Простые атрибуты: Не могут быть разделены на более мелкие компоненты (например, "Имя").
	•	Составные атрибуты: Могут быть разделены на более мелкие компоненты (например, "Адрес", который может состоять из "Улица", "Город", "Штат").
	•	Многозначные атрибуты: Могут принимать несколько значений для одного экземпляра сущности (например, "Телефонные номера" для сущности "Человек").
	•	Производные атрибуты: Значения которых могут быть вычислены на основе других атрибутов (например, "Возраст", который может быть вычислен на основе "Даты рождения").
Пример
Рассмотрим сущность "Студент":
	•	Сущность: Студент
	•	Атрибуты:
	•	Имя (строка)
	•	Фамилия (строка)
	•	Дата рождения (дата)
	•	Номер студенческого билета (целое число)
	•	Телефонные номера (многозначный атрибут)
В этом примере атрибуты предоставляют информацию о каждом студенте, и каждый атрибут имеет свои характеристики, такие как тип данных и обязательность.

2) какое действие будет предпринято, если объект check constraint  не пройдет при вставке?

Если объект CHECK CONSTRAINT не пройдет при попытке вставки или обновления данных в таблице в реляционной базе данных, то операция будет отменена, и данные не будут добавлены или изменены.

3) Какая из перечисленных служб управляет доступом к данным в реляционной базе данных?

В реляционных базах данных доступом к данным управляет система управления базами данных (СУБД). СУБД предоставляет механизмы для контроля доступа к данным, включая аутентификацию пользователей, авторизацию и управление правами доступа. PostgreSQL: Использует роли и привилегии для управления доступом к объектам базы данных.

4) Какая ddl  команда используетсядля создания check constrain?

Пример добавления ограничения CHECK в существующую таблицу
Если таблица уже существует, вы можете добавить ограничение CHECK с помощью команды ALTER TABLE:
ALTER TABLE Employees
ADD CONSTRAINT age_check CHECK (age > 0);  -- Добавление ограничения на возраст

5) dbl команда для создания foreign key?

ALTER TABLE Employees
ADD CONSTRAINT fk_department
FOREIGN KEY (department_id) REFERENCES Departments(id);  -- Добавление внешнего ключа

6) Что делает команда commit?

COMMIT используется для завершения транзакции и сохранения всех изменений, сделанных в базе данных с момента последнего COMMIT или ROLLBACK. Это означает, что все изменения, такие как вставка, обновление или удаление данных, становятся постоянными и видимыми для других пользователей.

7) ACID - какой принцип гарантирует, что если транзакция прошла успешно, то изменения будут сохранены?

Принцип, который гарантирует, что если транзакция прошла успешно, то изменения будут сохранены, называется Durability (долговечность).

8) CAP?

CAP теорема (также известная как теорема Бэра) — это принцип, который описывает ограничения, с которыми сталкиваются распределенные системы. Она утверждает, что в распределенной системе невозможно одновременно гарантировать три свойства:

Consistency (Согласованность): Все узлы системы видят одни и те же данные в одно и то же время. Это означает, что после завершения операции все пользователи должны видеть обновленные данные, и не должно быть расхождений между различными узлами.
Availability (Доступность): Каждый запрос к системе получает ответ, даже если некоторые узлы недоступны. Это означает, что система всегда отвечает на запросы, даже если некоторые данные могут быть устаревшими или недоступными.
Partition Tolerance (Устойчивость к разделению): Система продолжает функционировать, даже если происходит разделение сети, и узлы не могут обмениваться данными. Это означает, что система должна оставаться работоспособной, даже если некоторые узлы не могут общаться друг с другом.

9) какой из следующих языков используется для описания логических моделей данных?

Для описания логических моделей данных обычно используется язык моделирования данных, наиболее известным из которых является Unified Modeling Language (UML). UML предоставляет набор графических нотаций и диаграмм, которые позволяют визуализировать и описывать структуры данных, их взаимосвязи и поведение.

Другие языки и нотации, используемые для описания логических моделей данных:
Entity-Relationship (ER) Diagram: Это один из самых популярных методов для моделирования данных, который использует сущности, атрибуты и связи для описания структуры базы данных.
Object-Role Modeling (ORM): Это метод, который фокусируется на моделировании данных с использованием ролей объектов и их взаимосвязей.
Data Flow Diagrams (DFD): Эти диаграммы используются для описания потоков данных в системе, хотя они не всегда фокусируются на логической структуре данных.
Relational Model: Хотя это не язык в традиционном смысле, реляционная модель данных описывает данные в виде таблиц и отношений между ними, что также может быть использовано для логического моделирования.
Заключение
Таким образом, для описания логических моделей данных наиболее часто используется UML, а также ER-диаграммы и другие методы, в зависимости от конкретных требований и предпочтений проектирования.

10) Какое из следующих понятий описывает связь модели данных?

Связь модели данных обычно описывается понятием "отношение" или "связь" (relationship). В контексте моделирования данных, особенно в рамках ER-моделей (Entity-Relationship models), связь определяет, как различные сущности (entities) взаимодействуют друг с другом.

Основные аспекты связи в модели данных:
Типы связей:
Один к одному (1:1): Каждая запись в одной таблице соответствует ровно одной записи в другой таблице.
Один ко многим (1:N): Каждая запись в одной таблице может соответствовать нескольким записям в другой таблице, но каждая запись в другой таблице соответствует только одной записи в первой таблице.
Многие ко многим (M:N): Записи в одной таблице могут соответствовать нескольким записям в другой таблице, и наоборот. Для реализации таких связей часто используется промежуточная таблица.
Атрибуты связи: Связи могут иметь свои собственные атрибуты, которые описывают характеристики этой связи. Например, в связи "Студент записан на курс" атрибутом может быть "дата записи".
Внешние ключи: Связи между таблицами часто реализуются с помощью внешних ключей, которые ссылаются на первичные ключи других таблиц.
Пример
В ER-диаграмме можно увидеть, как сущности "Студент" и "Курс" могут быть связаны:

Студент (Student) может быть связан с Курсом (Course) через связь "записан на" (enrolled in), которая может быть типом "многие ко многим", если один студент может записываться на несколько курсов, а один курс может иметь много студентов.
Заключение
Таким образом, понятие, описывающее связь модели данных, — это "отношение" или "связь", которая определяет, как различные сущности взаимодействуют друг с другом в рамках модели данных.

11) 2 сущ-ни в логической модели данных?

Важнейшими компонентами логической модели данных являются:
Сущности, атрибуты и связи. Эти компоненты сохраняют своё первоначальное значение и назначение из концептуальной модели данных.
Типы данных. Каждому атрибуту назначаются определённые типы данных, определяя тип информации, которую он может хранить, например целые числа, строки или даты.
Ограничения. Определяются правила или ограничения, которым должны соответствовать данные, хранящиеся в атрибутах, такие как уникальность, ссылочная целостность или ограничения домена.

12) Что представляют собой 1NF?

Первая нормальная форма (1НФ) — это одно из основных правил нормализации баз данных, которое помогает организовать данные в реляционных таблицах. Она определяет, как должны быть структурированы данные, чтобы избежать избыточности и аномалий при обновлении.

Основные требования первой нормальной формы (1НФ):
Атомарность значений: Все значения в столбцах таблицы должны быть атомарными, то есть неделимыми. Это означает, что каждый столбец должен содержать только одно значение, а не набор значений или списки.
Однородность значений: Все значения в одном столбце должны быть одного и того же типа. Например, если столбец предназначен для хранения чисел, он не должен содержать строковые значения.
Уникальность строк: Каждая строка в таблице должна быть уникальной. Это обычно достигается с помощью первичного ключа, который однозначно идентифицирует каждую запись в таблице.
Отсутствие повторяющихся групп: Таблица не должна содержать повторяющихся групп или массивов. Если у вас есть несколько значений для одного атрибута, их следует вынести в отдельные строки или таблицы.

13) Что такое PK в физической модели данных?

PK (Primary Key) в физической модели данных обозначает первичный ключ. Это один из ключевых концептов в реляционных базах данных, который используется для уникальной идентификации каждой записи (строки) в таблице.

14) Какое действие будет предпринято, если объект check constrain не пройдет при вставке или обновлении данных?

Если объект CHECK CONSTRAINT не пройдет при попытке вставки или обновления данных в таблице, то операция будет отклонена, и изменения не будут применены. Это означает, что база данных не позволит сохранить данные, которые не соответствуют заданному условию ограничения.

15) Какая ddl команда поможет создать составной индекс в реляционной базе данных?

Для создания составного индекса в реляционной базе данных используется команда CREATE INDEX. Составной индекс — это индекс, который создается на основе двух или более столбцов таблицы. Он позволяет ускорить выполнение запросов, которые фильтруют или сортируют данные по этим столбцам.

CREATE INDEX index_name
ON table_name (column1, column2, ...);

16) Что подходит под термин реляционных баз данных?

Термин "реляционные базы данных" относится к типу систем управления базами данных (СУБД), которые организуют данные в виде таблиц (или реляций). Эти таблицы состоят из строк и столбцов, где каждая строка представляет собой отдельную запись, а каждый столбец — атрибут этой записи. Реляционные базы данных используют реляционную модель данных, предложенную Эдгаром Коддом в 1970-х годах.

Основные характеристики реляционных баз данных:
Табличная структура, Первичные и внешние ключи, SQL, Нормализация, ACID-принципы.

17) Укажите нереляционные базы данных из списка?

Нереляционные базы данных (или NoSQL базы данных) представляют собой системы управления базами данных, которые не используют реляционную модель данных. Они могут хранить данные в различных форматах, таких как документы, ключ-значение, графы или колонки. Вот несколько примеров нереляционных баз данных:

MongoDB: Документо-ориентированная база данных, которая хранит данные в формате JSON-подобных документов.
Cassandra: Колонно-ориентированная база данных, разработанная для обработки больших объемов данных с высокой доступностью и масштабируемостью.
Redis: База данных ключ-значение, которая хранит данные в памяти и обеспечивает высокую скорость доступа.
Couchbase: Документо-ориентированная база данных, которая сочетает в себе возможности NoSQL и реляционных баз данных.
Neo4j: Графовая база данных, которая используется для хранения и обработки данных в виде графов, что позволяет эффективно работать с взаимосвязями между данными.
DynamoDB: Сервис NoSQL от Amazon Web Services, который предлагает высокую производительность и масштабируемость.

18) SELECT CASE WHEN NULL = 5 THEN A
			WHEN NULL <> 5 Then B
			ELSE C
	END AS RESULT

Обе проверки NULL = 5 и NULL <> 5 вернут NULL, и, следовательно, ни одно из условий не будет истинным. В результате будет выполнен блок ELSE, и запрос вернет значение C.
Таким образом, результатом выполнения этого запроса будет значение C.

19) SELECT sum A(val) FROM (SELECT NULL::integer AS val) AS tl

вы используете подзапрос, который возвращает одно значение NULL в качестве val.

Функция SUM в SQL игнорирует NULL значения. Это означает, что если вы попытаетесь суммировать значения, и все они равны NULL, результатом будет NULL, а не 0.

Таким образом, результат выполнения этого запроса будет NULL.

20) SELECT 1 + 1 AS Val WHERE 1 = 1 AND 2 = 1;

вы пытаетесь выполнить выборку с условием WHERE. Однако в SQL, если вы не указываете FROM для выборки, то запрос будет некорректным.
В данном случае, условие 1 = 1 истинно, но 2 = 1 ложно, и поскольку оба условия должны быть истинными для выполнения запроса, итоговое условие 1 = 1 AND 2 = 1 будет ложным.
Таким образом, даже если бы запрос был корректным с точки зрения синтаксиса, он не вернул бы никаких строк, так как условие WHERE не выполняется.
Если бы запрос был написан с FROM, например:
SELECT 1 + 1 AS Val FROM dual WHERE 1 = 1 AND 2 = 1;
то он также не вернул бы никаких строк, так как условие 2 = 1 ложно.
В итоге, ваш исходный запрос не выполнится из-за отсутствия FROM, а если бы он был исправлен, то результатом было бы 0 строк.

21) SELECT string_agg(t1.id::varchar, ',' ORDERED BY t1.id) AS result 
FROM (SELECT s.id FROM student AS s UNION SELECT h.student_id FROM hobby AS d) AS t1;

вы выполняете следующие действия:

Подзапрос:
SELECT s.id FROM student AS s UNION SELECT h.student_id FROM hobby AS d объединяет уникальные значения id из таблицы student и student_id из таблицы hobby. Оператор UNION убирает дубликаты.
Основной запрос:
string_agg(t1.id::varchar, ',' ORDERED BY t1.id) создает строку, состоящую из значений id, разделенных запятыми, и отсортированных по id. Функция string_agg является стандартной в PostgreSQL и используется для агрегации строк.
Таким образом, результатом выполнения этого запроса будет строка, содержащая все уникальные идентификаторы студентов и их хобби, разделенные запятыми и отсортированные по возрастанию.

Если в подзапросе нет ни одного значения (например, если таблицы student и hobby пусты), то результат будет NULL. Если есть значения, то вы получите строку, содержащую эти значения, например: 1,2,3,4 (в зависимости от данных в таблицах).

22) SELECT count(*) 
FROM student AS s 
WHERE EXISTS (SELECT NULL FROM hobby AS h WHERE h.student_id = s.id LIMIT 1);

вы выполняете следующие действия:
Основной запрос:
SELECT count(*) FROM student AS s подсчитывает количество строк в таблице student.
Условие WHERE EXISTS:
EXISTS (SELECT NULL FROM hobby AS h WHERE h.student_id = s.id LIMIT 1) проверяет, существуют ли записи в таблице hobby, где student_id соответствует id студента из таблицы student.
Если хотя бы одна запись в таблице hobby соответствует условию, то EXISTS вернет TRUE, и студент будет включен в подсчет.
Таким образом, итоговый результат запроса будет равен количеству студентов, у которых есть хотя бы одно хобби, записанное в таблице hobby.
Если ни один студент не имеет хобби, результат будет равен 0. Если есть студенты с хобби, то результат будет равен количеству таких студентов.