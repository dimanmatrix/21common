# TERMINAL.H/C - Управление терминалом

## Обзор модуля

`gui/cli/terminal.c` реализует низкоуровневое управление терминалом для создания полноэкранного игрового интерфейса:
- **ANSI escape sequences** для цветов и управления курсором
- **Неблокирующий ввод** через настройку termios
- **Сохранение и восстановление** настроек терминала
- **Кроссплатформенная совместимость** (Unix/Linux/macOS)

## Константы и макросы

### ANSI цвета
**Файл:** `terminal.h:14-22`

```c
#define RESET "\033[0m"      // Сброс всех атрибутов
#define BOLD "\033[1m"       // Жирный текст
#define RED "\033[31m"       // Красный
#define GREEN "\033[32m"     // Зеленый
#define YELLOW "\033[33m"    // Желтый
#define BLUE "\033[34m"      // Синий
#define MAGENTA "\033[35m"   // Пурпурный
#define CYAN "\033[36m"      // Голубой
#define WHITE "\033[37m"     // Белый
```

### Управление курсором
**Файл:** `terminal.h:24-28`

```c
#define CLEAR_SCREEN "\033[2J\033[H"  // Очистка экрана + курсор в начало
#define HIDE_CURSOR "\033[?25l"       // Скрыть курсор
#define SHOW_CURSOR "\033[?25h"       // Показать курсор
#define CURSOR_HOME "\033[H"          // Курсор в позицию (1,1)
```

**ANSI escape sequences:**
- `\033[2J` - очистка всего экрана
- `\033[H` - позиция курсора в левый верхний угол
- `\033[?25l/h` - видимость курсора

## Внутреннее состояние

### Статические переменные
**Файл:** `terminal.c:14-15`

```c
static struct termios orig_termios;     // Оригинальные настройки терминала
static bool terminal_initialized = false; // Флаг инициализации
```

**Назначение:**
- Сохранение исходной конфигурации для восстановления
- Предотвращение повторной инициализации
- Безопасное завершение работы

## API функции

### terminal_setup() - Настройка неблокирующего ввода
**Файл:** `terminal.c:21-43`

```c
void terminal_setup(void) {
    if (terminal_initialized) {
        return;  // Предотвращение повторной инициализации
    }

    // Сохраняем оригинальные настройки
    tcgetattr(STDIN_FILENO, &orig_termios);

    struct termios raw = orig_termios;
    // Отключаем канонический режим и эхо
    raw.c_lflag &= ~(ECHO | ICANON);
    // Минимальное количество символов для чтения = 0
    raw.c_cc[VMIN] = 0;
    // Таймаут чтения = 0 (неблокирующий)
    raw.c_cc[VTIME] = 0;

    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);

    // Делаем stdin неблокирующим
    fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);

    terminal_initialized = true;
}
```

**Ключевые настройки termios:**

#### 1. Отключение канонического режима
```c
raw.c_lflag &= ~ICANON;
```
**Эффект:** Символы доступны немедленно, без ожидания Enter

#### 2. Отключение эха
```c
raw.c_lflag &= ~ECHO;
```
**Эффект:** Нажатые клавиши не отображаются в терминале

#### 3. Неблокирующее чтение
```c
raw.c_cc[VMIN] = 0;   // Минимум символов для возврата = 0
raw.c_cc[VTIME] = 0;  // Таймаут = 0 (немедленный возврат)
```
**Эффект:** `getchar()` возвращает EOF если нет ввода

#### 4. O_NONBLOCK для stdin
```c
fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK);
```
**Эффект:** Дублирует неблокирующее поведение на уровне файлового дескриптора

### terminal_restore() - Восстановление настроек
**Файл:** `terminal.c:45-53`

```c
void terminal_restore(void) {
    if (!terminal_initialized) {
        return;  // Не было инициализации
    }

    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
    terminal_show_cursor();  // Показываем курсор при выходе
    terminal_initialized = false;
}
```

**Последовательность восстановления:**
1. Проверка флага инициализации
2. Восстановление исходных termios настроек
3. Принудительное отображение курсора
4. Сброс флага инициализации

**Важность:** Без восстановления терминал остается в "сыром" режиме после завершения программы

### terminal_clear_screen() - Очистка экрана
**Файл:** `terminal.c:55-58`

```c
void terminal_clear_screen(void) {
    printf(CLEAR_SCREEN);  // "\033[2J\033[H"
    fflush(stdout);        // Принудительная отправка в терминал
}
```

**Действия:**
- `\033[2J` - стирает весь экран
- `\033[H` - курсор в позицию (1,1)
- `fflush()` - немедленная отправка без буферизации

### terminal_hide_cursor() - Скрытие курсора
**Файл:** `terminal.c:60-63`

```c
void terminal_hide_cursor(void) {
    printf(HIDE_CURSOR);  // "\033[?25l"
    fflush(stdout);
}
```

### terminal_show_cursor() - Отображение курсора
**Файл:** `terminal.c:65-68`

```c
void terminal_show_cursor(void) {
    printf(SHOW_CURSOR);  // "\033[?25h"
    fflush(stdout);
}
```

## Архитектурные принципы

### Безопасность состояния
- **Проверка инициализации** во всех функциях
- **Сохранение исходных настроек** для корректного восстановления
- **Предотвращение повторной инициализации**

### Кроссплатформенность
- Использование **POSIX стандартов** (termios, fcntl)
- **ANSI escape sequences** работают на большинстве терминалов
- Совместимость с Unix/Linux/macOS

### Минимализм
- Только необходимые функции для игры
- Простой и понятный API
- Нет сложных зависимостей

## Использование в приложении

### Последовательность вызовов
```c
// При запуске программы
terminal_setup();
terminal_hide_cursor();

// В игровом цикле
terminal_clear_screen();
// ... отрисовка игры ...

// При завершении (обязательно!)
terminal_restore();
```

### Интеграция с signal handlers
**Из main.c:**
```c
void signal_handler(int signum) {
    running = false;  // Устанавливает флаг завершения
}

// В cleanup_system():
terminal_restore();   // Восстанавливает терминал даже при Ctrl+C
```

## Особенности работы с ANSI

### Поддержка терминалов
- **Работает:** xterm, GNOME Terminal, iTerm2, macOS Terminal
- **Ограниченно:** старые терминалы, Windows Command Prompt
- **Не работает:** файловые перенаправления (`./game > output.txt`)

### Проблемы совместимости
1. **Windows Command Prompt** - требует включения ANSI поддержки
2. **Файловые перенаправления** - ANSI коды попадают в файл
3. **SSH сессии** - зависит от TERM переменной

### Проверка поддержки
```c
// Потенциальная проверка (не реализована)
bool terminal_supports_ansi(void) {
    char* term = getenv("TERM");
    return term && strstr(term, "xterm");
}
```

## Производительность

### Оптимизации
- **fflush()** только при необходимости
- **Минимальные ANSI последовательности**
- **Отсутствие сложных операций** в критическом пути

### Потенциальные улучшения
1. **Буферизация ANSI команд** для пакетной отправки
2. **Кэширование размеров терминала**
3. **Оптимизированная очистка** только измененных областей

## Отладка и тестирование

### DEBUG информация
Модуль не содержит DEBUG выводов, так как любые printf'ы могут нарушить отображение.

### Проблемы диагностики
1. **Терминал "завис"** - не вызван `terminal_restore()`
2. **Невидимый курсор** - не вызван `terminal_show_cursor()`
3. **Неработающий ввод** - проблемы с termios настройками

### Восстановление терминала вручную
```bash
# Если программа завершилась аварийно
reset              # Полный сброс терминала
tput cnorm        # Показать курсор
stty sane         # Восстановить нормальные настройки
```